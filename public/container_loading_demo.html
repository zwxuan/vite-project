<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é›†è£…ç®±è£…ç®±ä¼˜åŒ–ä¸å¯è§†åŒ–ç³»ç»Ÿ - å¢å¼ºç‰ˆ</title>
    
    <!-- Three.js åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { font-family: 'Microsoft YaHei', Arial, sans-serif; margin: 0; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #333; }
        .main-container { max-width: 1400px; margin: 0 auto; }
        h1 { color: white; text-align: center; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .dashboard { display: grid; grid-template-columns: 1fr 2fr 1fr; gap: 20px; margin-bottom: 20px; }
        .panel { background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); padding: 20px; backdrop-filter: blur(10px); }
        .cargo-management { min-height: 600px; }
        .visualization { min-height: 600px; position: relative; }
        .controls-panel { min-height: 600px; }
        #scene-container { width: 100%; height: 500px; background: linear-gradient(45deg, #f0f0f0, #e0e0e0); border-radius: 8px; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 600; color: #2c3e50; }
        .form-group input, .form-group select { width: calc(100% - 24px); padding: 10px; border: 2px solid #e1e8ed; border-radius: 6px; font-size: 14px; transition: border-color 0.3s; box-sizing: border-box; }
        .form-group input[type="checkbox"] { width: auto; margin-right: 8px; }
        .form-group label.checkbox-label { display: flex; align-items: center; margin-bottom: 5px; font-weight: 600; color: #2c3e50; }
        .form-group input:focus, .form-group select:focus { outline: none; border-color: #3498db; }
        .btn { background: linear-gradient(45deg, #3498db, #2980b9); color: white; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s; margin: 5px; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4); }
        .btn-success { background: linear-gradient(45deg, #27ae60, #229954); }
        .btn-warning { background: linear-gradient(45deg, #f39c12, #e67e22); }
        .btn-danger { background: linear-gradient(45deg, #e74c3c, #c0392b); }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 12px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background: linear-gradient(45deg, #34495e, #2c3e50); color: white; }
        .metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
        .metric-card { background: linear-gradient(45deg, #ecf0f1, #bdc3c7); padding: 15px; border-radius: 8px; text-align: center; }
        .metric-value { font-size: 24px; font-weight: bold; color: #2c3e50; }
        .metric-label { font-size: 12px; color: #7f8c8d; margin-top: 5px; }
        .algorithm-selector { margin: 15px 0; }
        .progress-bar { width: 100%; height: 20px; background: #ecf0f1; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: linear-gradient(45deg, #27ae60, #2ecc71); transition: width 0.3s; }
        .cargo-preview { width: 40px; height: 40px; background: #f8f9fa; border: 1px solid #dee2e6; display: flex; align-items: center; justify-content: center; border-radius: 4px; }
        .cargo-shape { border-radius: 2px; }
        .comparison-panel { grid-column: 1 / -1; margin-top: 20px; }
        .comparison-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .solution-card { background: white; border-radius: 8px; padding: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .tabs { display: flex; margin-bottom: 20px; }
        .tab { padding: 10px 20px; background: #ecf0f1; border: none; cursor: pointer; border-radius: 6px 6px 0 0; margin-right: 5px; }
        .tab.active { background: #3498db; color: white; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* è´§ç‰©ä¿¡æ¯æç¤ºæ¡†æ ·å¼ */
        .cargo-tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.92), rgba(30, 30, 30, 0.92));
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
            max-width: 280px;
            min-width: 200px;
            word-wrap: break-word;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            opacity: 0;
            transform: translateY(8px) scale(0.95);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .cargo-tooltip.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .cargo-tooltip.hide {
            opacity: 0;
            transform: translateY(-8px) scale(0.95);
            transition: all 0.15s cubic-bezier(0.4, 0, 1, 1);
        }
        
        .cargo-tooltip .cargo-name {
            font-weight: 600;
            color: #ffd700;
            margin-bottom: 8px;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 6px;
        }
        
        .cargo-tooltip .cargo-info {
            margin: 4px 0;
            font-size: 12px;
            display: flex;
            align-items: center;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .cargo-tooltip .cargo-info:before {
            content: 'â€¢';
            color: #4CAF50;
            margin-right: 6px;
            font-weight: bold;
            font-size: 10px;
        }
        
        /* å¤šé›†è£…ç®±è¯¦æƒ…æ ·å¼ */
        .container-detail-item {
            background: #f8f9fa;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }
        
        .container-detail-item h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 14px;
            font-weight: 600;
        }
        
        .detail-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .detail-metrics span {
            font-size: 12px;
            color: #666;
            background: white;
            padding: 4px 8px;
            border-radius: 3px;
            border: 1px solid #e9ecef;
        }
        
        #container-details {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background: white;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>ğŸš¢ é›†è£…ç®±è£…ç®±ä¼˜åŒ–ä¸å¯è§†åŒ–ç³»ç»Ÿ - å¢å¼ºç‰ˆ</h1>
        
        <div class="dashboard">
            <!-- è´§ç‰©ä¿¡æ¯ç®¡ç†é¢æ¿ -->
            <div class="panel cargo-management">
                <h2>ğŸ“¦ è´§ç‰©ä¿¡æ¯ç®¡ç†</h2>
                
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('basic')">åŸºç¡€ä¿¡æ¯</button>
                    <button class="tab" onclick="switchTab('advanced')">é«˜çº§å±æ€§</button>
                    <button class="tab" onclick="switchTab('batch')">æ‰¹é‡å¯¼å…¥</button>
                </div>
                
                <div id="basic-tab" class="tab-content active">
                    <div class="form-group">
                        <label for="container-type">é›†è£…ç®±è§„æ ¼</label>
                        <select id="container-type">
                            <option value="20ft">20ft GP (5.89Ã—2.35Ã—2.39m)</option>
                            <option value="40ft">40ft GP (12.03Ã—2.35Ã—2.39m)</option>
                            <option value="40ft-hq">40ft HQ (12.03Ã—2.35Ã—2.69m)</option>
                            <option value="45ft">45ft HQ (13.56Ã—2.35Ã—2.69m)</option>
                        </select>
                    </div>
                    
                    <form id="cargo-form">
                        <div class="form-group">
                            <label for="cargo-name">è´§ç‰©åç§°</label>
                            <input type="text" id="cargo-name" placeholder="ä¾‹å¦‚ï¼šçº¸ç®±ã€æœºæ¢°è®¾å¤‡" required>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                            <div class="form-group">
                                <label for="length">é•¿ (m)</label>
                                <input type="number" id="length" value="1.2" step="0.01" min="0.01" required>
                            </div>
                            <div class="form-group">
                                <label for="width">å®½ (m)</label>
                                <input type="number" id="width" value="0.8" step="0.01" min="0.01" required>
                            </div>
                            <div class="form-group">
                                <label for="height">é«˜ (m)</label>
                                <input type="number" id="height" value="1.0" step="0.01" min="0.01" required>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div class="form-group">
                                <label for="weight">é‡é‡ (kg)</label>
                                <input type="number" id="weight" value="100" step="0.1" min="0.1" required>
                            </div>
                            <div class="form-group">
                                <label for="quantity">æ•°é‡</label>
                                <input type="number" id="quantity" value="10" min="1" required>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-success">â• æ·»åŠ è´§ç‰©</button>
                    </form>
                </div>
                
                <div id="advanced-tab" class="tab-content">
                    <div class="form-group">
                        <label for="fragile">æ˜“ç¢å“</label>
                        <select id="fragile">
                            <option value="false">å¦</option>
                            <option value="true">æ˜¯</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="stackable">å¯å †å </label>
                        <select id="stackable">
                            <option value="true">æ˜¯</option>
                            <option value="false">å¦</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="max-stack">æœ€å¤§å †å å±‚æ•°</label>
                        <input type="number" id="max-stack" value="5" min="1">
                    </div>
                    <div class="form-group">
                        <label for="rotation">å…è®¸æ—‹è½¬</label>
                        <select id="rotation">
                            <option value="true">æ˜¯</option>
                            <option value="false">å¦</option>
                        </select>
                    </div>
                </div>
                
                <div id="batch-tab" class="tab-content">
                    <div class="form-group">
                        <label for="csv-file">CSVæ–‡ä»¶å¯¼å…¥</label>
                        <input type="file" id="csv-file" accept=".csv,.xlsx">
                    </div>
                    <button type="button" class="btn" onclick="downloadTemplate()">ğŸ“¥ ä¸‹è½½æ¨¡æ¿</button>
                    <button type="button" class="btn btn-success" onclick="importCargo()">ğŸ“¤ å¯¼å…¥è´§ç‰©</button>
                </div>
                
                <h3>ğŸ“‹ è´§ç‰©åˆ—è¡¨</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table id="cargo-table">
                        <thead>
                            <tr>
                                <th>é¢„è§ˆ</th>
                                <th>åç§°</th>
                                <th>å°ºå¯¸(LÃ—WÃ—H)</th>
                                <th>é‡é‡</th>
                                <th>æ•°é‡</th>
                                <th>æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="cargo-list-body"></tbody>
                    </table>
                </div>
                <div style="margin-top: 10px; text-align: center;">
                    <button class="btn btn-warning" onclick="clearAllCargo()" style="width: 100%;">ğŸ—‘ï¸ æ¸…ç©ºé›†è£…ç®±è´§ç‰©</button>
                </div>
            </div>
            
            <!-- 3Då¯è§†åŒ–é¢æ¿ -->
            <div class="panel visualization">
                <h2>ğŸ¯ 3D å¯è§†åŒ–è£…ç®±æ–¹æ¡ˆ</h2>
                <div id="scene-container"></div>
                <div style="margin-top: 10px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <div>
                        <button class="btn" onclick="resetCamera()">ğŸ¥ é‡ç½®è§†è§’</button>
                        <button class="btn" onclick="toggleWireframe()">ğŸ“ çº¿æ¡†æ¨¡å¼</button>
                        <button class="btn" onclick="exportModel()">ğŸ’¾ å¯¼å‡ºæ¨¡å‹</button>
                    </div>
                    <div>
                        <label>è§†å›¾: </label>
                        <select id="view-mode" onchange="changeView()">
                            <option value="perspective">é€è§†å›¾</option>
                            <option value="top">ä¿¯è§†å›¾</option>
                            <option value="side">ä¾§è§†å›¾</option>
                            <option value="front">æ­£è§†å›¾</option>
                        </select>
                    </div>
                </div>
                <div style="margin-top: 10px; display: flex; gap: 15px; flex-wrap: wrap; font-size: 12px;">
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="show-safety-lines" checked onchange="drawContainer()"> å®‰å…¨æ ‡çº¿
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="show-container-details" checked onchange="drawContainer()"> é›†è£…ç®±ç»†èŠ‚
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="show-work-areas" checked onchange="drawContainer()"> ä½œä¸šåŒºåŸŸ
                    </label>
                </div>
            </div>
            
            <!-- æ§åˆ¶ä¸ä¼˜åŒ–é¢æ¿ -->
            <div class="panel controls-panel">
                <h2>âš™ï¸ ç®—æ³•æ§åˆ¶ä¸ä¼˜åŒ–</h2>
                
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="multi-container-mode" onchange="toggleMultiContainerMode()"> å¤šé›†è£…ç®±æ™ºèƒ½é€‰æ‹©æ¨¡å¼
                    </label>
                </div>
                
                <div class="algorithm-selector">
                    <label for="algorithm">è£…ç®±ç®—æ³•</label>
                    <select id="algorithm">
                        <option value="greedy">è´ªå¿ƒç®—æ³• (å¿«é€Ÿ)</option>
                        <option value="genetic">é—ä¼ ç®—æ³• (æœ€ä¼˜)</option>
                        <option value="simulated">æ¨¡æ‹Ÿé€€ç« (å¹³è¡¡)</option>
                        <option value="hybrid">æ··åˆç®—æ³• (æ¨è)</option>
                        <option value="multi-container">å¤šé›†è£…ç®±ä¼˜åŒ– (æ™ºèƒ½)</option>
                    </select>
                </div>
                
                <div id="multi-container-options" style="display: none;">
                    <div class="form-group">
                        <label for="max-containers">æœ€å¤§é›†è£…ç®±æ•°é‡</label>
                        <input type="number" id="max-containers" value="5" min="1" max="20">
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="mixed-container-types" checked> å…è®¸æ··åˆé›†è£…ç®±ç±»å‹
                        </label>
                    </div>
                    <div class="form-group">
                        <label for="cost-optimization">æˆæœ¬ä¼˜åŒ–ç­–ç•¥</label>
                        <select id="cost-optimization">
                            <option value="minimize-containers">æœ€å°‘é›†è£…ç®±æ•°é‡</option>
                            <option value="minimize-cost">æœ€ä½è¿è¾“æˆæœ¬</option>
                            <option value="maximize-utilization">æœ€é«˜ç©ºé—´åˆ©ç”¨ç‡</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="optimization-time">ä¼˜åŒ–æ—¶é—´ (ç§’)</label>
                    <input type="range" id="optimization-time" min="5" max="60" value="15">
                    <span id="time-display">15ç§’</span>
                </div>
                
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="weight-balance" checked> é‡å¿ƒå¹³è¡¡çº¦æŸ
                    </label>
                </div>
                
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="fragile-protection" checked> æ˜“ç¢å“ä¿æŠ¤
                    </label>
                </div>
                
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="show-grid" checked onchange="drawContainer()"> æ˜¾ç¤ºåœ°é¢ç½‘æ ¼
                    </label>
                </div>
                
                <button class="btn btn-success" onclick="calculateOptimal()" style="width: 100%; margin: 10px 0;">ğŸš€ ç”Ÿæˆæœ€ä¼˜æ–¹æ¡ˆ</button>
                
                <div id="calculation-progress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div style="text-align: center; margin-top: 5px;">è®¡ç®—ä¸­... <span id="progress-text">0%</span></div>
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="load-ratio">0%</div>
                        <div class="metric-label">è£…è½½ç‡</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="loaded-items">0</div>
                        <div class="metric-label">å·²è£…è½½</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="total-weight">0kg</div>
                        <div class="metric-label">æ€»é‡é‡</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="center-deviation">0cm</div>
                        <div class="metric-label">é‡å¿ƒåç§»</div>
                    </div>
                </div>
                
                <div id="multi-container-metrics" style="display: none;">
                    <h4>ğŸ“¦ å¤šé›†è£…ç®±ç»Ÿè®¡</h4>
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-value" id="container-count">0</div>
                            <div class="metric-label">é›†è£…ç®±æ•°é‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="total-cost">Â¥0</div>
                            <div class="metric-label">é¢„ä¼°æˆæœ¬</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="avg-utilization">0%</div>
                            <div class="metric-label">å¹³å‡åˆ©ç”¨ç‡</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="unloaded-items">0</div>
                            <div class="metric-label">æœªè£…è½½è´§ç‰©</div>
                        </div>
                    </div>
                    
                    <div id="container-details" style="margin-top: 15px; max-height: 200px; overflow-y: auto;"></div>
                </div>
                
                <!-- è£…ç®±è¯´æ˜åŒºåŸŸ -->
                <div id="packing-summary" style="margin-top: 20px; display: none;">
                    <h3>ğŸ“‹ è£…ç®±è¯´æ˜</h3>
                    <div id="packing-description" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #007bff; font-size: 14px; line-height: 1.6;"></div>
                </div>
                
                <h3>ğŸ“Š æ–¹æ¡ˆå¯¹æ¯”</h3>
                <div id="solutions-list"></div>
                <button class="btn" onclick="saveSolution()">ğŸ’¾ ä¿å­˜å½“å‰æ–¹æ¡ˆ</button>
                <button class="btn btn-warning" onclick="clearSolutions()">ğŸ—‘ï¸ æ¸…ç©ºæ–¹æ¡ˆ</button>
                
                <h3>ğŸ“¤ å¯¼å‡ºé€‰é¡¹</h3>
                <button class="btn" onclick="exportPDF()">ğŸ“„ å¯¼å‡ºPDF</button>
                <button class="btn" onclick="exportExcel()">ğŸ“Š å¯¼å‡ºExcel</button>
                <button class="btn btn-danger" onclick="resetAll()">ğŸ”„ é‡ç½®æ‰€æœ‰</button>
            </div>
        </div>
        
        <!-- æ–¹æ¡ˆå¯¹æ¯”é¢æ¿ -->
        <div class="panel comparison-panel" id="comparison-panel" style="display: none;">
            <h2>ğŸ“ˆ æ–¹æ¡ˆå¯¹æ¯”åˆ†æ</h2>
            <div class="comparison-grid" id="comparison-grid"></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let cargoItems = [];
        let solutions = [];
        let currentSolution = null;
        let scene, camera, renderer, controls, raycaster, mouse;
        let tooltip = null;
        let hoveredCargo = null;
        let containerGroup, cargoGroup;
        let multiContainerMode = false;
        let containerGroups = [];
        let multiContainerSolution = null;
        
        // é›†è£…ç®±è§„æ ¼æ•°æ®
        const containerDimensions = {
            '20ft': { length: 5.89, width: 2.35, height: 2.39, maxWeight: 28230, cost: 2000 },
            '40ft': { length: 12.03, width: 2.35, height: 2.39, maxWeight: 28750, cost: 3500 },
            '40ft-hq': { length: 12.03, width: 2.35, height: 2.69, maxWeight: 28750, cost: 3800 },
            '45ft': { length: 13.56, width: 2.35, height: 2.69, maxWeight: 29000, cost: 4200 }
        };
        
        // å¤šé›†è£…ç®±æ–¹æ¡ˆç±»
        class MultiContainerSolution {
            constructor(containers, totalMetrics) {
                this.id = Date.now();
                this.containers = containers; // æ¯ä¸ªé›†è£…ç®±çš„è¯¦ç»†ä¿¡æ¯
                this.totalMetrics = totalMetrics;
                this.timestamp = new Date();
            }
        }
        
        // é›†è£…ç®±å®ä¾‹ç±»
        class ContainerInstance {
            constructor(type, placements, metrics) {
                this.type = type;
                this.placements = placements;
                this.metrics = metrics;
                this.position = { x: 0, y: 0, z: 0 }; // åœ¨åœºæ™¯ä¸­çš„ä½ç½®
            }
        }
        
        // è´§ç‰©ç±»å®šä¹‰
        class Cargo {
            constructor(data) {
                this.id = Date.now() + Math.random();
                this.name = data.name || 'æœªå‘½åè´§ç‰©';
                this.length = parseFloat(data.length);
                this.width = parseFloat(data.width);
                this.height = parseFloat(data.height);
                this.weight = parseFloat(data.weight);
                this.quantity = parseInt(data.quantity);
                this.fragile = data.fragile === 'true';
                this.stackable = data.stackable !== 'false';
                this.maxStack = parseInt(data.maxStack) || 5;
                this.rotation = data.rotation !== 'false';
                this.color = this.generateColor();
            }
            
            generateColor() {
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            getVolume() {
                return this.length * this.width * this.height;
            }
            
            getTotalWeight() {
                return this.weight * this.quantity;
            }
        }
        
        // è£…ç®±æ–¹æ¡ˆç±»
        class PackingSolution {
            constructor(algorithm, placements, metrics) {
                this.id = Date.now();
                this.algorithm = algorithm;
                this.placements = placements;
                this.metrics = metrics;
                this.timestamp = new Date();
            }
        }
        
        // åˆå§‹åŒ–3Dåœºæ™¯
        function initScene() {
            const container = document.getElementById('scene-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // ç¯å…‰è®¾ç½®
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // å°„çº¿æ£€æµ‹å™¨
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // é¼ æ ‡äº‹ä»¶ç›‘å¬
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseleave', onMouseLeave, false);
            
            drawContainer();
            animate();
        }
        
        // ç»˜åˆ¶é›†è£…ç®±
        function drawContainer() {
            if (containerGroup) scene.remove(containerGroup);
            
            containerGroup = new THREE.Group();
            const type = document.getElementById('container-type').value;
            const dims = containerDimensions[type];
            
            // é›†è£…ç®±ä¸»ä½“ï¼ˆé€æ˜ï¼‰
            const geometry = new THREE.BoxGeometry(dims.length, dims.height, dims.width);
            const material = new THREE.MeshStandardMaterial({
                color: 0x4A90E2,
                opacity: 0.1,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const containerMesh = new THREE.Mesh(geometry, material);
            containerMesh.receiveShadow = true;
            
            // è¾¹æ¡†
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            containerMesh.add(line);
            
            // æ·»åŠ é›†è£…ç®±ç»†èŠ‚ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
            const showDetails = document.getElementById('show-container-details')?.checked !== false;
            if (showDetails) {
                // æ·»åŠ é›†è£…ç®±è§’ä»¶
                addCornerFittings(containerMesh, dims);
                
                // æ·»åŠ é—¨æŠŠæ‰‹å’Œé—¨ç»†èŠ‚
                addDoorDetails(containerMesh, dims);
                
                // æ·»åŠ é›†è£…ç®±æ ‡è¯†ç‰Œå’Œç¼–å·
                addContainerLabels(containerMesh, dims);
            }
            
            containerGroup.add(containerMesh);
            
            // åˆ›å»ºæ··å‡åœŸè´¨æ„Ÿåœ°é¢
            createConcreteGround(dims);
            
            // æ·»åŠ å®‰å…¨æ ‡çº¿å’Œä½œä¸šåŒºåŸŸæ ‡è®°ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
            const showSafetyLines = document.getElementById('show-safety-lines')?.checked !== false;
            const showWorkAreas = document.getElementById('show-work-areas')?.checked !== false;
            if (showSafetyLines || showWorkAreas) {
                addSafetyMarkings(dims, showSafetyLines, showWorkAreas);
            }
            
            // å¯é€‰çš„ç½‘æ ¼æ˜¾ç¤º
            addOptionalGrid(dims);
            
            scene.add(containerGroup);
            
            // è®¾ç½®ç›¸æœºä½ç½®
            camera.position.set(dims.length * 1.5, dims.height * 2, dims.width * 1.5);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        // æ·»åŠ é›†è£…ç®±è§’ä»¶
        function addCornerFittings(containerMesh, dims) {
            const cornerSize = 0.15;
            const cornerGeometry = new THREE.BoxGeometry(cornerSize, cornerSize, cornerSize);
            const cornerMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
            
            // 8ä¸ªè§’çš„ä½ç½®
            const corners = [
                [-dims.length/2, -dims.height/2, -dims.width/2],
                [dims.length/2, -dims.height/2, -dims.width/2],
                [-dims.length/2, dims.height/2, -dims.width/2],
                [dims.length/2, dims.height/2, -dims.width/2],
                [-dims.length/2, -dims.height/2, dims.width/2],
                [dims.length/2, -dims.height/2, dims.width/2],
                [-dims.length/2, dims.height/2, dims.width/2],
                [dims.length/2, dims.height/2, dims.width/2]
            ];
            
            corners.forEach(corner => {
                const cornerMesh = new THREE.Mesh(cornerGeometry, cornerMaterial);
                cornerMesh.position.set(corner[0], corner[1], corner[2]);
                containerMesh.add(cornerMesh);
            });
        }
        
        // æ·»åŠ é—¨æŠŠæ‰‹å’Œé—¨ç»†èŠ‚
        function addDoorDetails(containerMesh, dims) {
            // é—¨æŠŠæ‰‹
            const handleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3);
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const leftHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            leftHandle.position.set(dims.length/2 + 0.01, 0, -dims.width/4);
            leftHandle.rotation.z = Math.PI/2;
            containerMesh.add(leftHandle);
            
            const rightHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            rightHandle.position.set(dims.length/2 + 0.01, 0, dims.width/4);
            rightHandle.rotation.z = Math.PI/2;
            containerMesh.add(rightHandle);
            
            // é—¨ç¼çº¿
            const doorLineGeometry = new THREE.BoxGeometry(0.02, dims.height * 0.9, 0.02);
            const doorLineMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            const doorLine = new THREE.Mesh(doorLineGeometry, doorLineMaterial);
            doorLine.position.set(dims.length/2 + 0.005, 0, 0);
            containerMesh.add(doorLine);
        }
        
        // æ·»åŠ é›†è£…ç®±æ ‡è¯†ç‰Œå’Œç¼–å·
        function addContainerLabels(containerMesh, dims) {
            // åˆ›å»ºæ ‡è¯†ç‰ŒèƒŒæ™¯
            const labelGeometry = new THREE.PlaneGeometry(1.5, 0.8);
            const labelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                side: THREE.DoubleSide
            });
            
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.set(-dims.length/2 - 0.01, dims.height/4, 0);
            label.rotation.y = Math.PI/2;
            containerMesh.add(label);
            
            // æ·»åŠ æ–‡å­—çº¹ç†ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä½¿ç”¨Canvasçº¹ç†ï¼‰
            const textGeometry = new THREE.PlaneGeometry(1.2, 0.3);
            const textMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                transparent: true,
                opacity: 0.8
            });
            
            const containerNumber = new THREE.Mesh(textGeometry, textMaterial);
            containerNumber.position.set(-dims.length/2 - 0.015, dims.height/4, 0);
            containerNumber.rotation.y = Math.PI/2;
            containerMesh.add(containerNumber);
        }
        
        // åˆ›å»ºé›†è£…ç®±ç½‘æ ¼ï¼ˆç”¨äºå•é›†è£…ç®±æ¨¡å¼ï¼‰
        function createContainerMesh(containerType) {
            const dims = containerDimensions[containerType];
            
            // é›†è£…ç®±ä¸»ä½“ï¼ˆé€æ˜ï¼‰
            const geometry = new THREE.BoxGeometry(dims.length, dims.height, dims.width);
            const material = new THREE.MeshStandardMaterial({
                color: 0x4A90E2,
                opacity: 0.1,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const containerMesh = new THREE.Mesh(geometry, material);
            containerMesh.receiveShadow = true;
            
            // æ·»åŠ æ ‡è¯†ï¼Œç”¨äºé¼ æ ‡äº¤äº’
            containerMesh.userData.isContainer = true;
            containerMesh.userData.containerType = containerType;
            
            // è¾¹æ¡†
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            containerMesh.add(line);
            
            // æ·»åŠ é›†è£…ç®±ç»†èŠ‚
            addCornerFittings(containerMesh, dims);
            addDoorDetails(containerMesh, dims);
            addContainerLabels(containerMesh, dims);
            
            return containerMesh;
        }
        
        // åˆ›å»ºæ··å‡åœŸè´¨æ„Ÿåœ°é¢
        function createConcreteGround(dims) {
            const groundSize = Math.max(dims.length, dims.width) + 8;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            
            // åˆ›å»ºæ··å‡åœŸçº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // åŸºç¡€æ··å‡åœŸè‰²
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(0, 0, 512, 512);
            
            // æ·»åŠ å™ªç‚¹å’Œçº¹ç†
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 3;
                const opacity = Math.random() * 0.3;
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${opacity})`;
                ctx.fillRect(x, y, size, size);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -dims.height / 2 - 0.01;
            ground.receiveShadow = true;
            containerGroup.add(ground);
        }
        
        // æ·»åŠ å®‰å…¨æ ‡çº¿å’Œä½œä¸šåŒºåŸŸæ ‡è®°
        function addSafetyMarkings(dims, showSafetyLines = true, showWorkAreas = true) {
            const lineWidth = 0.15;
            const lineHeight = 0.02;
            
            // é»„è‰²å®‰å…¨æ ‡çº¿æè´¨
            const yellowLineMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            
            // é›†è£…ç®±å‘¨å›´çš„å®‰å…¨æ ‡çº¿
            if (showSafetyLines) {
                const safetyDistance = 1.5;
                const lineGeometry = new THREE.BoxGeometry(dims.length + safetyDistance * 2, lineHeight, lineWidth);
                
                // å‰åå®‰å…¨çº¿
                const frontLine = new THREE.Mesh(lineGeometry, yellowLineMaterial);
                frontLine.position.set(0, -dims.height/2 + lineHeight/2, dims.width/2 + safetyDistance);
                containerGroup.add(frontLine);
                
                const backLine = new THREE.Mesh(lineGeometry, yellowLineMaterial);
                backLine.position.set(0, -dims.height/2 + lineHeight/2, -dims.width/2 - safetyDistance);
                containerGroup.add(backLine);
                
                // å·¦å³å®‰å…¨çº¿
                const sideLineGeometry = new THREE.BoxGeometry(lineWidth, lineHeight, dims.width + safetyDistance * 2);
                
                const leftLine = new THREE.Mesh(sideLineGeometry, yellowLineMaterial);
                leftLine.position.set(-dims.length/2 - safetyDistance, -dims.height/2 + lineHeight/2, 0);
                containerGroup.add(leftLine);
                
                const rightLine = new THREE.Mesh(sideLineGeometry, yellowLineMaterial);
                rightLine.position.set(dims.length/2 + safetyDistance, -dims.height/2 + lineHeight/2, 0);
                containerGroup.add(rightLine);
            }
            
            // ä½œä¸šåŒºåŸŸæ ‡è®°
            if (showWorkAreas) {
                addWorkAreaMarkings(dims, yellowLineMaterial);
                
                // é›†è£…ç®±å®šä½æ ‡è®°
                addPositioningMarks(dims, yellowLineMaterial);
            }
        }
        
        // æ·»åŠ ä½œä¸šåŒºåŸŸæ ‡è®°
        function addWorkAreaMarkings(dims, material) {
            const markSize = 0.3;
            const markGeometry = new THREE.RingGeometry(markSize * 0.7, markSize, 0, Math.PI * 2, 8);
            
            // å››ä¸ªè§’çš„ä½œä¸šåŒºåŸŸæ ‡è®°
            const workAreas = [
                [-dims.length/2 - 2, -dims.width/2 - 2],
                [dims.length/2 + 2, -dims.width/2 - 2],
                [-dims.length/2 - 2, dims.width/2 + 2],
                [dims.length/2 + 2, dims.width/2 + 2]
            ];
            
            workAreas.forEach(area => {
                const mark = new THREE.Mesh(markGeometry, material);
                mark.rotation.x = -Math.PI / 2;
                mark.position.set(area[0], -dims.height/2 + 0.01, area[1]);
                containerGroup.add(mark);
            });
        }
        
        // æ·»åŠ é›†è£…ç®±å®šä½æ ‡è®°
        function addPositioningMarks(dims, material) {
            const crossSize = 0.5;
            const crossWidth = 0.05;
            
            // åå­—å®šä½æ ‡è®°
            const horizontalGeometry = new THREE.BoxGeometry(crossSize, 0.01, crossWidth);
            const verticalGeometry = new THREE.BoxGeometry(crossWidth, 0.01, crossSize);
            
            // é›†è£…ç®±å››ä¸ªè§’çš„å®šä½æ ‡è®°
            const positions = [
                [-dims.length/2, -dims.width/2],
                [dims.length/2, -dims.width/2],
                [-dims.length/2, dims.width/2],
                [dims.length/2, dims.width/2]
            ];
            
            positions.forEach(pos => {
                const horizontal = new THREE.Mesh(horizontalGeometry, material);
                horizontal.position.set(pos[0], -dims.height/2 + 0.005, pos[1]);
                containerGroup.add(horizontal);
                
                const vertical = new THREE.Mesh(verticalGeometry, material);
                vertical.position.set(pos[0], -dims.height/2 + 0.005, pos[1]);
                containerGroup.add(vertical);
            });
        }
        
        // å¯é€‰çš„ç½‘æ ¼æ˜¾ç¤º
        function addOptionalGrid(dims) {
            const showGrid = document.getElementById('show-grid')?.checked !== false;
            if (showGrid) {
                const gridSize = Math.max(dims.length, dims.width) + 6;
                const gridHelper = new THREE.GridHelper(gridSize, 30, 0x888888, 0xCCCCCC);
                gridHelper.position.y = -dims.height / 2 + 0.001;
                gridHelper.material.opacity = 0.3;
                gridHelper.material.transparent = true;
                containerGroup.add(gridHelper);
            }
        }
        
        // ä¸ºå¤šé›†è£…ç®±æ¨¡å¼åˆ›å»ºç‹¬ç«‹çš„åœ°é¢
        function createConcreteGroundForContainer(dims, offsetX, offsetZ) {
            const groundSize = Math.max(dims.length, dims.width) + 4;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            
            // åˆ›å»ºæ··å‡åœŸçº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // åŸºç¡€æ··å‡åœŸè‰²
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(0, 0, 256, 256);
            
            // æ·»åŠ å™ªç‚¹å’Œçº¹ç†
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const size = Math.random() * 2;
                const opacity = Math.random() * 0.3;
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${opacity})`;
                ctx.fillRect(x, y, size, size);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(offsetX, -dims.height / 2 - 0.01, offsetZ);
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        // ä¸ºå¤šé›†è£…ç®±æ¨¡å¼æ·»åŠ å®‰å…¨æ ‡çº¿å’Œåœ°æ ‡
        function addSafetyMarkingsForContainer(dims, offsetX, offsetZ) {
            const lineWidth = 0.15;
            const lineHeight = 0.02;
            const safetyDistance = 1.5;
            
            // é»„è‰²å®‰å…¨æ ‡çº¿æè´¨
            const yellowLineMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            
            // é›†è£…ç®±å‘¨å›´çš„å®‰å…¨æ ‡çº¿
            const frontLineGeometry = new THREE.BoxGeometry(dims.length + safetyDistance * 2, lineHeight, lineWidth);
            
            // å‰åå®‰å…¨çº¿
            const frontLine = new THREE.Mesh(frontLineGeometry, yellowLineMaterial);
            frontLine.position.set(offsetX, -dims.height/2 + lineHeight/2, offsetZ + dims.width/2 + safetyDistance);
            scene.add(frontLine);
            
            const backLine = new THREE.Mesh(frontLineGeometry, yellowLineMaterial);
            backLine.position.set(offsetX, -dims.height/2 + lineHeight/2, offsetZ - dims.width/2 - safetyDistance);
            scene.add(backLine);
            
            // å·¦å³å®‰å…¨çº¿
            const sideLineGeometry = new THREE.BoxGeometry(lineWidth, lineHeight, dims.width + safetyDistance * 2);
            
            const leftLine = new THREE.Mesh(sideLineGeometry, yellowLineMaterial);
            leftLine.position.set(offsetX - dims.length/2 - safetyDistance, -dims.height/2 + lineHeight/2, offsetZ);
            scene.add(leftLine);
            
            const rightLine = new THREE.Mesh(sideLineGeometry, yellowLineMaterial);
            rightLine.position.set(offsetX + dims.length/2 + safetyDistance, -dims.height/2 + lineHeight/2, offsetZ);
            scene.add(rightLine);
            
            // æ·»åŠ ä½œä¸šåŒºåŸŸæ ‡è®°
            const markSize = 0.3;
            const markGeometry = new THREE.RingGeometry(markSize * 0.7, markSize, 0, Math.PI * 2, 8);
            
            // å››ä¸ªè§’çš„ä½œä¸šåŒºåŸŸæ ‡è®°
            const workAreas = [
                [offsetX - dims.length/2 - 2, offsetZ - dims.width/2 - 2],
                [offsetX + dims.length/2 + 2, offsetZ - dims.width/2 - 2],
                [offsetX - dims.length/2 - 2, offsetZ + dims.width/2 + 2],
                [offsetX + dims.length/2 + 2, offsetZ + dims.width/2 + 2]
            ];
            
            workAreas.forEach(area => {
                const mark = new THREE.Mesh(markGeometry, yellowLineMaterial);
                mark.rotation.x = -Math.PI / 2;
                mark.position.set(area[0], -dims.height/2 + 0.01, area[1]);
                scene.add(mark);
            });
            
            // æ·»åŠ é›†è£…ç®±å®šä½æ ‡è®°
            const crossSize = 0.5;
            const crossWidth = 0.05;
            
            // åå­—å®šä½æ ‡è®°
            const horizontalGeometry = new THREE.BoxGeometry(crossSize, 0.01, crossWidth);
            const verticalGeometry = new THREE.BoxGeometry(crossWidth, 0.01, crossSize);
            
            // é›†è£…ç®±å››ä¸ªè§’çš„å®šä½æ ‡è®°
            const positions = [
                [offsetX - dims.length/2, offsetZ - dims.width/2],
                [offsetX + dims.length/2, offsetZ - dims.width/2],
                [offsetX - dims.length/2, offsetZ + dims.width/2],
                [offsetX + dims.length/2, offsetZ + dims.width/2]
            ];
            
            positions.forEach(pos => {
                const horizontal = new THREE.Mesh(horizontalGeometry, yellowLineMaterial);
                horizontal.position.set(pos[0], -dims.height/2 + 0.005, pos[1]);
                scene.add(horizontal);
                
                const vertical = new THREE.Mesh(verticalGeometry, yellowLineMaterial);
                vertical.position.set(pos[0], -dims.height/2 + 0.005, pos[1]);
                scene.add(vertical);
            });
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // æ ‡ç­¾é¡µåˆ‡æ¢
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        }
        
        // è¡¨å•æäº¤å¤„ç†
        document.getElementById('cargo-form').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const formData = {
                name: document.getElementById('cargo-name').value,
                length: document.getElementById('length').value,
                width: document.getElementById('width').value,
                height: document.getElementById('height').value,
                weight: document.getElementById('weight').value,
                quantity: document.getElementById('quantity').value,
                fragile: document.getElementById('fragile').value,
                stackable: document.getElementById('stackable').value,
                maxStack: document.getElementById('max-stack').value,
                rotation: document.getElementById('rotation').value
            };
            
            const cargo = new Cargo(formData);
            cargoItems.push(cargo);
            updateCargoList();
            this.reset();
            
            // é‡ç½®ä¸ºé»˜è®¤å€¼
            document.getElementById('cargo-name').value = '';
            document.getElementById('length').value = '1.2';
            document.getElementById('width').value = '0.8';
            document.getElementById('height').value = '1.0';
            document.getElementById('weight').value = '100';
            document.getElementById('quantity').value = '10';
        });
        
        // æ›´æ–°è´§ç‰©åˆ—è¡¨
        function updateCargoList() {
            const tbody = document.getElementById('cargo-list-body');
            tbody.innerHTML = '';
            
            cargoItems.forEach((cargo, index) => {
                const row = document.createElement('tr');
                
                // è®¡ç®—é¢„è§ˆå°ºå¯¸
                const maxDim = 30;
                const scale = maxDim / Math.max(cargo.length, cargo.width, cargo.height);
                const previewWidth = Math.max(cargo.width * scale, 8);
                const previewHeight = Math.max(cargo.height * scale, 8);
                
                row.innerHTML = `
                    <td>
                        <div class="cargo-preview">
                            <div class="cargo-shape" style="width:${previewWidth}px; height:${previewHeight}px; background-color:${cargo.color};"></div>
                        </div>
                    </td>
                    <td title="${cargo.name}">${cargo.name.length > 8 ? cargo.name.substring(0, 8) + '...' : cargo.name}</td>
                    <td>${cargo.length}Ã—${cargo.width}Ã—${cargo.height}</td>
                    <td>${cargo.weight}kg</td>
                    <td>${cargo.quantity}</td>
                    <td><button class="btn btn-danger" style="padding: 2px 6px; font-size: 10px;" onclick="removeCargo(${index})">åˆ é™¤</button></td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        // åˆ é™¤è´§ç‰©
        function removeCargo(index) {
            cargoItems.splice(index, 1);
            updateCargoList();
        }
        
        // æ¸…ç©ºé›†è£…ç®±å†…è´§ç‰©
        function clearAllCargo() {
            // æ£€æŸ¥æ˜¯å¦æœ‰å·²è£…è½½çš„è´§ç‰©
            if (!cargoGroup || cargoGroup.children.length === 0) {
                alert('é›†è£…ç®±å†…æ²¡æœ‰è´§ç‰©ï¼');
                return;
            }
            
            if (confirm('ç¡®å®šè¦æ¸…ç©ºé›†è£…ç®±å†…çš„è´§ç‰©å—ï¼Ÿè´§ç‰©åˆ—è¡¨å°†ä¿æŒä¸å˜ã€‚')) {
                // æ¸…é™¤3Dåœºæ™¯ä¸­çš„è´§ç‰©
                if (cargoGroup) {
                    scene.remove(cargoGroup);
                    cargoGroup = new THREE.Group();
                }
                
                // é‡ç½®æŒ‡æ ‡æ˜¾ç¤º
                document.getElementById('load-ratio').textContent = '0%';
                document.getElementById('loaded-items').textContent = '0';
                document.getElementById('total-weight').textContent = '0kg';
                document.getElementById('center-deviation').textContent = '0cm';
                
                alert('é›†è£…ç®±å†…è´§ç‰©å·²æ¸…ç©ºï¼è´§ç‰©åˆ—è¡¨ä¿æŒä¸å˜ã€‚');
            }
        }
        
        // ä¼˜åŒ–æ—¶é—´æ»‘å—
        document.getElementById('optimization-time').addEventListener('input', function() {
            document.getElementById('time-display').textContent = this.value + 'ç§’';
        });
        
        // é›†è£…ç®±ç±»å‹å˜æ›´
        document.getElementById('container-type').addEventListener('change', drawContainer);
        
        // åˆ‡æ¢å¤šé›†è£…ç®±æ¨¡å¼
        function toggleMultiContainerMode() {
            multiContainerMode = document.getElementById('multi-container-mode').checked;
            const multiOptions = document.getElementById('multi-container-options');
            const multiMetrics = document.getElementById('multi-container-metrics');
            const algorithmSelect = document.getElementById('algorithm');
            
            if (multiContainerMode) {
                multiOptions.style.display = 'block';
                multiMetrics.style.display = 'block';
                algorithmSelect.value = 'multi-container';
            } else {
                multiOptions.style.display = 'none';
                multiMetrics.style.display = 'none';
                if (algorithmSelect.value === 'multi-container') {
                    algorithmSelect.value = 'hybrid';
                }
            }
            
            // æ¸…é™¤ç°æœ‰æ˜¾ç¤º
            clearContainerDisplay();
        }
        
        // ç”Ÿæˆæœ€ä¼˜è£…ç®±æ–¹æ¡ˆ
        function calculateOptimal() {
            if (cargoItems.length === 0) {
                alert('è¯·å…ˆæ·»åŠ è´§ç‰©ï¼');
                return;
            }
            
            const algorithm = document.getElementById('algorithm').value;
            const optimizationTime = parseInt(document.getElementById('optimization-time').value);
            
            if (algorithm === 'multi-container' || multiContainerMode) {
                // å¤šé›†è£…ç®±ä¼˜åŒ–
                showProgress(true);
                simulateCalculation(algorithm, optimizationTime);
            } else {
                // å•é›†è£…ç®±ä¼˜åŒ–
                showProgress(false);
                simulateCalculation(algorithm, optimizationTime);
            }
        }
        
        // æ˜¾ç¤ºè®¡ç®—è¿›åº¦
        function showProgress(isMultiContainer = false) {
            document.getElementById('calculation-progress').style.display = 'block';
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 10;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    setTimeout(() => {
                        document.getElementById('calculation-progress').style.display = 'none';
                        if (isMultiContainer) {
                            generateMultiContainerResult();
                        } else {
                            generatePackingResult();
                        }
                    }, 500);
                }
                
                progressFill.style.width = progress + '%';
                progressText.textContent = Math.round(progress) + '%';
            }, 200);
        }
        
        // æ¨¡æ‹Ÿç®—æ³•è®¡ç®—
        function simulateCalculation(algorithm, time) {
            // è¿™é‡Œå¯ä»¥å®ç°çœŸå®çš„ç®—æ³•é€»è¾‘
            console.log(`ä½¿ç”¨${algorithm}ç®—æ³•ï¼Œä¼˜åŒ–æ—¶é—´${time}ç§’`);
        }
        
        // å¤šé›†è£…ç®±è®¡ç®—æ¨¡æ‹Ÿ
        function simulateMultiContainerCalculation(time) {
            console.log(`ä½¿ç”¨å¤šé›†è£…ç®±ä¼˜åŒ–ç®—æ³•ï¼Œä¼˜åŒ–æ—¶é—´${time}ç§’`);
            
            // å»¶è¿Ÿæ‰§è¡Œä»¥æ¨¡æ‹Ÿè®¡ç®—è¿‡ç¨‹
            setTimeout(() => {
                document.getElementById('calculation-progress').style.display = 'none';
                generateMultiContainerResult();
            }, time * 100); // ç¼©çŸ­æ¨¡æ‹Ÿæ—¶é—´
        }
        
        // æ¸…é™¤é›†è£…ç®±æ˜¾ç¤º
        function clearContainerDisplay() {
            // æ¸…é™¤æ‰€æœ‰é›†è£…ç®±ç»„
            containerGroups.forEach(group => {
                if (group.containerGroup) scene.remove(group.containerGroup);
                if (group.cargoGroup) scene.remove(group.cargoGroup);
            });
            containerGroups = [];
            
            // æ¸…é™¤å•é›†è£…ç®±æ˜¾ç¤º
            if (containerGroup) scene.remove(containerGroup);
            if (cargoGroup) scene.remove(cargoGroup);
            
            multiContainerSolution = null;
        }
        
        // ç”Ÿæˆå¤šé›†è£…ç®±è£…ç®±ç»“æœ
         function generateMultiContainerResult() {
             clearContainerDisplay();
             
             const maxContainers = parseInt(document.getElementById('max-containers').value);
             const mixedTypes = document.getElementById('mixed-container-types').checked;
             const costStrategy = document.getElementById('cost-optimization').value;
             
             // æ™ºèƒ½é€‰æ‹©é›†è£…ç®±ç±»å‹å’Œæ•°é‡
             const containerSolution = optimizeContainerSelection(cargoItems, maxContainers, mixedTypes, costStrategy);
             
             // åˆ›å»ºå¤šé›†è£…ç®±3Dæ˜¾ç¤º
             createMultiContainerVisualization(containerSolution);
             
             // æ›´æ–°å¤šé›†è£…ç®±æŒ‡æ ‡
             updateMultiContainerMetrics(containerSolution);
             
             // ä¿å­˜å¤šé›†è£…ç®±æ–¹æ¡ˆ
             multiContainerSolution = new MultiContainerSolution(containerSolution.containers, containerSolution.totalMetrics);
         }
         
         // æ™ºèƒ½é›†è£…ç®±é€‰æ‹©ä¼˜åŒ–ç®—æ³•
         function optimizeContainerSelection(cargoItems, maxContainers, mixedTypes, strategy) {
             const containerTypes = mixedTypes ? Object.keys(containerDimensions) : [document.getElementById('container-type').value];
             let bestSolution = null;
             let bestScore = -1;
             
             // è®¡ç®—æ‰€æœ‰è´§ç‰©çš„æ€»ä½“ç§¯å’Œé‡é‡
             const totalCargoVolume = cargoItems.reduce((sum, item) => sum + item.getVolume() * item.quantity, 0);
             const totalCargoWeight = cargoItems.reduce((sum, item) => sum + item.weight * item.quantity, 0);
             
             // ä¼°ç®—æœ€å°‘éœ€è¦çš„é›†è£…ç®±æ•°é‡
             let minContainersNeeded = 1;
             if (containerTypes.length > 0) {
                 const largestContainer = containerTypes.reduce((largest, type) => {
                     const container = containerDimensions[type];
                     const largestVol = containerDimensions[largest] ? 
                         containerDimensions[largest].length * containerDimensions[largest].width * containerDimensions[largest].height : 0;
                     const currentVol = container.length * container.width * container.height;
                     return currentVol > largestVol ? type : largest;
                 }, containerTypes[0]);
                 
                 const largestContainerVol = containerDimensions[largestContainer].length * 
                     containerDimensions[largestContainer].width * containerDimensions[largestContainer].height;
                 const largestContainerWeight = containerDimensions[largestContainer].maxWeight;
                 
                 minContainersNeeded = Math.max(
                     Math.ceil(totalCargoVolume / (largestContainerVol * 0.8)), // è€ƒè™‘80%çš„å®é™…è£…è½½ç‡
                     Math.ceil(totalCargoWeight / largestContainerWeight)
                 );
             }
             
             // åŠ¨æ€è°ƒæ•´æœ€å¤§é›†è£…ç®±æ•°é‡ï¼Œç¡®ä¿èƒ½è£…è½½æ‰€æœ‰è´§ç‰©
             const dynamicMaxContainers = Math.max(maxContainers, minContainersNeeded * 2);
             
             // å°è¯•ä¸åŒçš„é›†è£…ç®±ç»„åˆï¼Œç›´åˆ°æ‰¾åˆ°èƒ½è£…è½½æ‰€æœ‰è´§ç‰©çš„æ–¹æ¡ˆ
             for (let numContainers = 1; numContainers <= dynamicMaxContainers; numContainers++) {
                 const solution = tryContainerCombination(cargoItems, containerTypes, numContainers, strategy);
                 const score = evaluateSolution(solution, strategy);
                 
                 // å¦‚æœæ‰€æœ‰è´§ç‰©éƒ½è£…è½½å®Œæ¯•ï¼Œä¼˜å…ˆé€‰æ‹©è¿™ä¸ªæ–¹æ¡ˆ
                 if (solution.totalMetrics.totalUnloadedItems === 0) {
                     if (bestSolution === null || 
                         solution.totalMetrics.totalUnloadedItems < bestSolution.totalMetrics.totalUnloadedItems ||
                         (solution.totalMetrics.totalUnloadedItems === bestSolution.totalMetrics.totalUnloadedItems && score > bestScore)) {
                         bestScore = score;
                         bestSolution = solution;
                         // å¯¹äºæœ€å°‘é›†è£…ç®±æ•°é‡ç­–ç•¥ï¼Œæ‰¾åˆ°èƒ½è£…è½½æ‰€æœ‰è´§ç‰©çš„æ–¹æ¡ˆå°±å¯ä»¥ç»“æŸ
                         if (strategy === 'minimize-containers') {
                             break;
                         }
                         // å¯¹äºå…¶ä»–ç­–ç•¥ï¼Œç»§ç»­å¯»æ‰¾æ›´ä¼˜çš„æ–¹æ¡ˆï¼Œä½†ç¡®ä¿èƒ½è£…è½½æ‰€æœ‰è´§ç‰©
                     }
                 } else if (bestSolution === null || 
                           solution.totalMetrics.totalUnloadedItems < bestSolution.totalMetrics.totalUnloadedItems ||
                           (solution.totalMetrics.totalUnloadedItems === bestSolution.totalMetrics.totalUnloadedItems && score > bestScore)) {
                     bestScore = score;
                     bestSolution = solution;
                 }
             }
             
             // å¦‚æœæ²¡æœ‰æ‰¾åˆ°èƒ½è£…è½½æ‰€æœ‰è´§ç‰©çš„æ–¹æ¡ˆï¼Œç»§ç»­å¢åŠ é›†è£…ç®±æ•°é‡ç›´åˆ°èƒ½è£…è½½æ‰€æœ‰è´§ç‰©
             if (bestSolution && bestSolution.totalMetrics.totalUnloadedItems > 0) {
                 for (let numContainers = dynamicMaxContainers + 1; numContainers <= dynamicMaxContainers * 3; numContainers++) {
                     const solution = tryContainerCombination(cargoItems, containerTypes, numContainers, strategy);
                     if (solution.totalMetrics.totalUnloadedItems === 0) {
                         const score = evaluateSolution(solution, strategy);
                         if (bestSolution === null || 
                             solution.totalMetrics.totalUnloadedItems < bestSolution.totalMetrics.totalUnloadedItems ||
                             (solution.totalMetrics.totalUnloadedItems === bestSolution.totalMetrics.totalUnloadedItems && score > bestScore)) {
                             bestScore = score;
                             bestSolution = solution;
                         }
                         break; // æ‰¾åˆ°èƒ½è£…è½½æ‰€æœ‰è´§ç‰©çš„æ–¹æ¡ˆå°±åœæ­¢
                     }
                 }
             }
             
             return bestSolution;
         }
         
         // å°è¯•é›†è£…ç®±ç»„åˆ
         function tryContainerCombination(cargoItems, containerTypes, numContainers, strategy) {
             const containers = [];
             let remainingCargo = [...cargoItems];
             let totalCost = 0;
             let totalLoadedItems = 0;
             let totalUnloadedItems = 0;
             
             for (let i = 0; i < numContainers && remainingCargo.length > 0; i++) {
                 // é€‰æ‹©æœ€é€‚åˆçš„é›†è£…ç®±ç±»å‹
                 const bestType = selectBestContainerType(remainingCargo, containerTypes, strategy);
                 const container = containerDimensions[bestType];
                 
                 // ä¸ºå½“å‰é›†è£…ç®±è£…è½½è´§ç‰©
                 const packingResult = packSingleContainer(remainingCargo, bestType);
                 
                 if (packingResult.placements.length > 0) {
                     containers.push(new ContainerInstance(bestType, packingResult.placements, packingResult.metrics));
                     totalCost += container.cost;
                     totalLoadedItems += packingResult.metrics.loadedItems;
                     
                     // ç§»é™¤å·²è£…è½½çš„è´§ç‰©
                     remainingCargo = updateRemainingCargo(remainingCargo, packingResult.placements);
                 } else {
                     // å¦‚æœå½“å‰é›†è£…ç®±æ— æ³•è£…è½½ä»»ä½•è´§ç‰©ï¼Œå°è¯•å…¶ä»–ç±»å‹çš„é›†è£…ç®±
                     let foundAlternative = false;
                     for (const altType of containerTypes) {
                         if (altType !== bestType) {
                             const altPackingResult = packSingleContainer(remainingCargo, altType);
                             if (altPackingResult.placements.length > 0) {
                                 const altContainer = containerDimensions[altType];
                                 containers.push(new ContainerInstance(altType, altPackingResult.placements, altPackingResult.metrics));
                                 totalCost += altContainer.cost;
                                 totalLoadedItems += altPackingResult.metrics.loadedItems;
                                 remainingCargo = updateRemainingCargo(remainingCargo, altPackingResult.placements);
                                 foundAlternative = true;
                                 break;
                             }
                         }
                     }
                     // å¦‚æœæ‰€æœ‰ç±»å‹çš„é›†è£…ç®±éƒ½æ— æ³•è£…è½½å‰©ä½™è´§ç‰©ï¼Œè·³å‡ºå¾ªç¯
                     if (!foundAlternative) {
                         break;
                     }
                 }
             }
             
             // è®¡ç®—æœªè£…è½½è´§ç‰©æ•°é‡
             remainingCargo.forEach(cargo => {
                 totalUnloadedItems += cargo.quantity;
             });
             
             return {
                 containers: containers,
                 totalMetrics: {
                     containerCount: containers.length,
                     totalCost: totalCost,
                     totalLoadedItems: totalLoadedItems,
                     totalUnloadedItems: totalUnloadedItems,
                     avgUtilization: containers.length > 0 ? containers.reduce((sum, c) => sum + c.metrics.loadRatio, 0) / containers.length : 0
                 }
             };
         }
         
         // é€‰æ‹©æœ€ä½³é›†è£…ç®±ç±»å‹
         function selectBestContainerType(remainingCargo, containerTypes, strategy) {
             let bestType = containerTypes[0];
             let bestScore = -1;
             
             for (const type of containerTypes) {
                 const score = evaluateContainerType(remainingCargo, type, strategy);
                 if (score > bestScore) {
                     bestScore = score;
                     bestType = type;
                 }
             }
             
             return bestType;
         }
         
         // è¯„ä¼°é›†è£…ç®±ç±»å‹é€‚åˆåº¦
         function evaluateContainerType(cargo, containerType, strategy) {
             const container = containerDimensions[containerType];
             const totalVolume = cargo.reduce((sum, item) => sum + item.getVolume() * item.quantity, 0);
             const containerVolume = container.length * container.width * container.height;
             const utilization = Math.min(totalVolume / containerVolume, 1);
             
             switch (strategy) {
                 case 'minimize-cost':
                     return utilization / container.cost * 10000; // æ€§ä»·æ¯”
                 case 'maximize-utilization':
                     return utilization;
                 case 'minimize-containers':
                 default:
                     return utilization * containerVolume; // ä¼˜å…ˆé€‰æ‹©èƒ½è£…æ›´å¤šè´§ç‰©çš„å¤§ç®±å­
             }
         }
         
         // å•ä¸ªé›†è£…ç®±è£…è½½
         function packSingleContainer(cargoItems, containerType) {
             const container = containerDimensions[containerType];
             let totalVolume = 0;
             let totalWeight = 0;
             let loadedCount = 0;
             let placements = [];
             
             // æŒ‰ä½“ç§¯ä»å¤§åˆ°å°æ’åºè´§ç‰©ï¼Œä½†åŒæ—¶è€ƒè™‘é‡é‡
             const sortedCargo = [...cargoItems].sort((a, b) => {
                 const volumeA = a.getVolume();
                 const volumeB = b.getVolume();
                 const densityA = a.weight / volumeA;
                 const densityB = b.weight / volumeB;
                 // ä¼˜å…ˆè£…è½½ä½“ç§¯å¤§ä¸”å¯†åº¦é€‚ä¸­çš„è´§ç‰©
                 return (volumeB * 0.7 + densityB * 0.3) - (volumeA * 0.7 + densityA * 0.3);
             });
             
             // ä½¿ç”¨æ›´æ™ºèƒ½çš„è£…ç®±ç®—æ³•
             const layers = [];
             let currentLayer = {
                 y: -container.height / 2,
                 height: 0,
                 rows: []
             };
             
             for (const cargo of sortedCargo) {
                 let remainingQuantity = cargo.quantity;
                 
                 while (remainingQuantity > 0) {
                     // æ£€æŸ¥é‡é‡é™åˆ¶
                     if (totalWeight + cargo.weight > container.maxWeight) {
                         break;
                     }
                     
                     // å°è¯•åœ¨å½“å‰å±‚æ”¾ç½®è´§ç‰©
                     const placement = findBestPosition(cargo, currentLayer, container);
                     
                     if (placement) {
                         placements.push({
                             cargo: cargo,
                             position: placement.position,
                             rotation: { x: 0, y: 0, z: 0 }
                         });
                         
                         totalVolume += cargo.getVolume();
                         totalWeight += cargo.weight;
                         loadedCount++;
                         remainingQuantity--;
                         
                         // æ›´æ–°å½“å‰å±‚ä¿¡æ¯
                         updateLayerInfo(currentLayer, cargo, placement);
                     } else {
                         // å½“å‰å±‚æ— æ³•æ”¾ç½®ï¼Œå°è¯•åˆ›å»ºæ–°å±‚
                         if (currentLayer.y + currentLayer.height + cargo.height <= container.height / 2) {
                             layers.push(currentLayer);
                             currentLayer = {
                                 y: currentLayer.y + currentLayer.height,
                                 height: cargo.height,
                                 rows: []
                             };
                             
                             // åœ¨æ–°å±‚å°è¯•æ”¾ç½®
                             const newPlacement = findBestPosition(cargo, currentLayer, container);
                             if (newPlacement) {
                                 placements.push({
                                     cargo: cargo,
                                     position: newPlacement.position,
                                     rotation: { x: 0, y: 0, z: 0 }
                                 });
                                 
                                 totalVolume += cargo.getVolume();
                                 totalWeight += cargo.weight;
                                 loadedCount++;
                                 remainingQuantity--;
                                 
                                 updateLayerInfo(currentLayer, cargo, newPlacement);
                             } else {
                                 break; // æ— æ³•æ”¾ç½®ï¼Œè·³å‡ºå¾ªç¯
                             }
                         } else {
                             break; // é«˜åº¦ä¸å¤Ÿï¼Œè·³å‡ºå¾ªç¯
                         }
                     }
                 }
             }
             
             const containerVolume = container.length * container.width * container.height;
             const loadRatio = (totalVolume / containerVolume * 100);
             
             return {
                 placements: placements,
                 metrics: {
                     loadRatio: loadRatio,
                     loadedItems: loadedCount,
                     totalWeight: totalWeight,
                     centerDeviation: calculateCenterDeviation(placements, container)
                 }
             };
         }
         
         // å¯»æ‰¾æœ€ä½³æ”¾ç½®ä½ç½®
         function findBestPosition(cargo, layer, container) {
             // å¦‚æœå±‚ä¸ºç©ºï¼Œä»èµ·å§‹ä½ç½®å¼€å§‹
             if (layer.rows.length === 0) {
                 const position = {
                     x: -container.length / 2 + cargo.length / 2,
                     y: layer.y + cargo.height / 2,
                     z: -container.width / 2 + cargo.width / 2
                 };
                 
                 // æ£€æŸ¥æ˜¯å¦åœ¨å®¹å™¨èŒƒå›´å†…
                 if (position.x + cargo.length / 2 <= container.length / 2 &&
                     position.z + cargo.width / 2 <= container.width / 2) {
                     layer.height = Math.max(layer.height, cargo.height);
                     return { position };
                 }
                 return null;
             }
             
             // å°è¯•åœ¨ç°æœ‰è¡Œä¸­æ‰¾ä½ç½®
             for (const row of layer.rows) {
                 const nextX = row.endX;
                 if (nextX + cargo.length <= container.length / 2) {
                     const position = {
                         x: nextX + cargo.length / 2,
                         y: layer.y + cargo.height / 2,
                         z: row.z
                     };
                     return { position, rowIndex: layer.rows.indexOf(row) };
                 }
             }
             
             // å°è¯•åˆ›å»ºæ–°è¡Œ
             const lastRow = layer.rows[layer.rows.length - 1];
             const nextZ = lastRow ? lastRow.z + lastRow.width : -container.width / 2 + cargo.width / 2;
             
             if (nextZ + cargo.width / 2 <= container.width / 2) {
                 const position = {
                     x: -container.length / 2 + cargo.length / 2,
                     y: layer.y + cargo.height / 2,
                     z: nextZ
                 };
                 return { position, newRow: true };
             }
             
             return null;
         }
         
         // æ›´æ–°å±‚ä¿¡æ¯
         function updateLayerInfo(layer, cargo, placement) {
             layer.height = Math.max(layer.height, cargo.height);
             
             if (placement.newRow) {
                 layer.rows.push({
                     z: placement.position.z,
                     width: cargo.width,
                     endX: placement.position.x + cargo.length / 2
                 });
             } else if (placement.rowIndex !== undefined) {
                 layer.rows[placement.rowIndex].endX = placement.position.x + cargo.length / 2;
             } else if (layer.rows.length === 0) {
                 layer.rows.push({
                     z: placement.position.z,
                     width: cargo.width,
                     endX: placement.position.x + cargo.length / 2
                 });
             }
         }
         
         // æ›´æ–°å‰©ä½™è´§ç‰©
         function updateRemainingCargo(remainingCargo, placements) {
             const updated = [];
             
             for (const cargo of remainingCargo) {
                 const loadedCount = placements.filter(p => p.cargo.id === cargo.id).length;
                 const remaining = cargo.quantity - loadedCount;
                 
                 if (remaining > 0) {
                     const newCargo = new Cargo({
                         name: cargo.name,
                         length: cargo.length,
                         width: cargo.width,
                         height: cargo.height,
                         weight: cargo.weight,
                         quantity: remaining,
                         fragile: cargo.fragile,
                         stackable: cargo.stackable,
                         maxStack: cargo.maxStack,
                         rotation: cargo.rotation
                     });
                     newCargo.id = cargo.id;
                     newCargo.color = cargo.color;
                     updated.push(newCargo);
                 }
             }
             
             return updated;
         }
         
         // è¯„ä¼°æ–¹æ¡ˆ
         function evaluateSolution(solution, strategy) {
             if (!solution || solution.containers.length === 0) return 0;
             
             const metrics = solution.totalMetrics;
             
             switch (strategy) {
                 case 'minimize-cost':
                     return (metrics.totalLoadedItems / metrics.totalCost) * 1000;
                 case 'maximize-utilization':
                     return metrics.avgUtilization;
                 case 'minimize-containers':
                 default:
                     return metrics.totalLoadedItems / metrics.containerCount * 100;
             }
         }
         
         // ç”Ÿæˆè£…ç®±ç»“æœï¼ˆå•é›†è£…ç®±æ¨¡å¼ï¼‰
         function generatePackingResult() {
             // æ¸…é™¤ç°æœ‰æ˜¾ç¤º
             if (cargoGroup) scene.remove(cargoGroup);
             if (containerGroup) scene.remove(containerGroup);
             cargoGroup = new THREE.Group();
             containerGroup = new THREE.Group();
             
             const containerType = document.getElementById('container-type').value;
             const container = containerDimensions[containerType];
             
             // åˆ›å»ºé›†è£…ç®±3Dæ¨¡å‹
             const containerMesh = createContainerMesh(containerType);
             containerGroup.add(containerMesh);
             
             // æ·»åŠ åœ°é¢å’Œå®‰å…¨æ ‡è®°
             createConcreteGround(container);
             addSafetyMarkings(container, true, true);
             
             scene.add(containerGroup);
             
             let currentX = -container.length / 2;
             let currentY = -container.height / 2;
             let currentZ = -container.width / 2;
             let totalVolume = 0;
             let totalWeight = 0;
             let loadedCount = 0;
             let placements = [];
             
             // æ”¹è¿›çš„è£…ç®±ç®—æ³•
             for (const cargo of cargoItems) {
                 for (let i = 0; i < cargo.quantity; i++) {
                     // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢è¡Œ
                     if (currentX + cargo.length > container.length / 2) {
                         currentX = -container.length / 2;
                         currentZ += 1.0; // å›ºå®šé—´è·
                     }
                     
                     // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢å±‚
                     if (currentZ + cargo.width > container.width / 2) {
                         currentZ = -container.width / 2;
                         currentY += 1.2; // å›ºå®šé«˜åº¦
                     }
                     
                     // æ£€æŸ¥æ˜¯å¦è¶…å‡ºå®¹å™¨é«˜åº¦
                     if (currentY + cargo.height > container.height / 2) {
                         break;
                     }
                     
                     // æ£€æŸ¥é‡é‡é™åˆ¶
                     if (totalWeight + cargo.weight > container.maxWeight) {
                         break;
                     }
                     
                     // åˆ›å»ºè´§ç‰©3Dæ¨¡å‹
                     const geometry = new THREE.BoxGeometry(cargo.length, cargo.height, cargo.width);
                     const material = new THREE.MeshStandardMaterial({ 
                         color: cargo.color,
                         transparent: false
                     });
                     
                     const mesh = new THREE.Mesh(geometry, material);
                     mesh.position.set(
                         currentX + cargo.length / 2,
                         currentY + cargo.height / 2,
                         currentZ + cargo.width / 2
                     );
                     
                     mesh.castShadow = true;
                     mesh.receiveShadow = true;
                     
                     // æ·»åŠ è´§ç‰©ä¿¡æ¯åˆ°userData
                     mesh.userData.cargoInfo = {
                         name: cargo.name,
                         length: cargo.length,
                         width: cargo.width,
                         height: cargo.height,
                         weight: cargo.weight,
                         quantity: cargo.quantity,
                         fragile: cargo.fragile,
                         stackable: cargo.stackable,
                         position: {
                             x: mesh.position.x,
                             y: mesh.position.y,
                             z: mesh.position.z
                         }
                     };
                     
                     // æ·»åŠ è¾¹æ¡†
                     const edges = new THREE.EdgesGeometry(geometry);
                     const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                     mesh.add(line);
                     
                     cargoGroup.add(mesh);
                     
                     // è®°å½•æ”¾ç½®ä¿¡æ¯
                     placements.push({
                         cargo: cargo,
                         position: { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z },
                         rotation: { x: 0, y: 0, z: 0 }
                     });
                     
                     currentX += cargo.length;
                     totalVolume += cargo.getVolume();
                     totalWeight += cargo.weight;
                     loadedCount++;
                 }
             }
             
             scene.add(cargoGroup);
             
             // æ›´æ–°æŒ‡æ ‡
             const containerVolume = container.length * container.width * container.height;
             const loadRatio = (totalVolume / containerVolume * 100).toFixed(1);
             const centerDeviation = calculateCenterDeviation(placements, container);
             
             document.getElementById('load-ratio').textContent = loadRatio + '%';
             document.getElementById('loaded-items').textContent = loadedCount;
             document.getElementById('total-weight').textContent = totalWeight.toFixed(0) + 'kg';
             document.getElementById('center-deviation').textContent = centerDeviation.toFixed(1) + 'cm';
             
             // ä¿å­˜å½“å‰æ–¹æ¡ˆ
             const algorithm = document.getElementById('algorithm').value;
             currentSolution = new PackingSolution(algorithm, placements, {
                 loadRatio: parseFloat(loadRatio),
                 loadedItems: loadedCount,
                 totalWeight: totalWeight,
                 centerDeviation: centerDeviation
             });
             
             // ç”Ÿæˆå¹¶æ˜¾ç¤ºå•é›†è£…ç®±è£…ç®±è¯´æ˜
             generateSingleContainerSummary(currentSolution, containerType);
         }
         
         // ç”Ÿæˆå•é›†è£…ç®±è£…ç®±è¯´æ˜
         function generateSingleContainerSummary(solution, containerType) {
             const container = containerDimensions[containerType];
             const metrics = solution.metrics;
             const placements = solution.placements;
             
             // ç»Ÿè®¡è´§ç‰©ä¿¡æ¯
             const cargoStats = {};
             placements.forEach(placement => {
                 const cargoName = placement.cargo.name;
                 if (!cargoStats[cargoName]) {
                     cargoStats[cargoName] = {
                         count: 0,
                         totalWeight: 0,
                         totalVolume: 0,
                         cargo: placement.cargo
                     };
                 }
                 cargoStats[cargoName].count++;
                 cargoStats[cargoName].totalWeight += placement.cargo.weight;
                 cargoStats[cargoName].totalVolume += placement.cargo.getVolume();
             });
             
             let summary = `<strong>ğŸš› å•é›†è£…ç®±è£…è½½æ–¹æ¡ˆ</strong><br><br>`;
             summary += `<strong>é›†è£…ç®±è§„æ ¼ï¼š</strong>${containerType} (${container.length.toFixed(2)}m Ã— ${container.width.toFixed(2)}m Ã— ${container.height.toFixed(2)}m)<br>`;
             summary += `<strong>æœ€å¤§è½½é‡ï¼š</strong>${container.maxWeight.toLocaleString()}kg<br>`;
             summary += `<strong>é¢„ä¼°æˆæœ¬ï¼š</strong>Â¥${container.cost.toLocaleString()}<br><br>`;
             
             summary += `<strong>ğŸ“Š è£…è½½ç»Ÿè®¡ï¼š</strong><br>`;
             summary += `â€¢ è£…è½½ç‡ï¼š${metrics.loadRatio}%<br>`;
             summary += `â€¢ å·²è£…è½½è´§ç‰©ï¼š${metrics.loadedItems}ä»¶<br>`;
             summary += `â€¢ æ€»é‡é‡ï¼š${metrics.totalWeight.toFixed(0)}kg<br>`;
             summary += `â€¢ é‡å¿ƒåç§»ï¼š${metrics.centerDeviation.toFixed(1)}cm<br><br>`;
             
             summary += `<strong>ğŸ“¦ è´§ç‰©æ¸…å•ï¼š</strong><br>`;
             Object.values(cargoStats).forEach(stat => {
                 summary += `â€¢ ${stat.cargo.name}ï¼š${stat.count}ä»¶ï¼Œ${stat.totalWeight.toFixed(0)}kgï¼Œ${stat.totalVolume.toFixed(2)}mÂ³<br>`;
             });
             
             // è®¡ç®—æœªè£…è½½è´§ç‰©
             const unloadedItems = [];
             cargoItems.forEach(cargo => {
                 const loadedCount = placements.filter(p => p.cargo.id === cargo.id).length;
                 const remaining = cargo.quantity - loadedCount;
                 if (remaining > 0) {
                     unloadedItems.push(`${cargo.name}ï¼š${remaining}ä»¶`);
                 }
             });
             
             if (unloadedItems.length > 0) {
                 summary += `<br><strong>âš ï¸ æœªè£…è½½è´§ç‰©ï¼š</strong><br>`;
                 unloadedItems.forEach(item => {
                     summary += `â€¢ ${item}<br>`;
                 });
             }
             
             document.getElementById('packing-description').innerHTML = summary;
             document.getElementById('packing-summary').style.display = 'block';
         }
         
         // ç”Ÿæˆå¤šé›†è£…ç®±è£…ç®±è¯´æ˜
         function generatePackingSummary(containerSolution) {
             if (!containerSolution) return;
             
             const containers = containerSolution.containers;
             const metrics = containerSolution.totalMetrics;
             
             let summary = `<strong>ğŸšš å¤šé›†è£…ç®±æ™ºèƒ½è£…è½½æ–¹æ¡ˆ</strong><br><br>`;
             summary += `<strong>ğŸ“Š æ€»ä½“ç»Ÿè®¡ï¼š</strong><br>`;
             summary += `â€¢ ä½¿ç”¨é›†è£…ç®±ï¼š${metrics.containerCount}ä¸ª<br>`;
             summary += `â€¢ é¢„ä¼°æ€»æˆæœ¬ï¼šÂ¥${metrics.totalCost.toLocaleString()}<br>`;
             summary += `â€¢ å¹³å‡åˆ©ç”¨ç‡ï¼š${metrics.avgUtilization.toFixed(1)}%<br>`;
             summary += `â€¢ å·²è£…è½½è´§ç‰©ï¼š${metrics.totalLoadedItems}ä»¶<br>`;
             summary += `â€¢ æœªè£…è½½è´§ç‰©ï¼š${metrics.totalUnloadedItems}ä»¶<br><br>`;
             
             containers.forEach((container, index) => {
                 const containerInfo = containerDimensions[container.type];
                 summary += `<strong>ğŸ“¦ é›†è£…ç®± ${index + 1} (${container.type})</strong><br>`;
                 summary += `â€¢ è§„æ ¼ï¼š${containerInfo.length.toFixed(2)}m Ã— ${containerInfo.width.toFixed(2)}m Ã— ${containerInfo.height.toFixed(2)}m<br>`;
                 summary += `â€¢ åˆ©ç”¨ç‡ï¼š${container.metrics.loadRatio.toFixed(1)}%<br>`;
                 summary += `â€¢ è£…è½½è´§ç‰©ï¼š${container.metrics.loadedItems}ä»¶<br>`;
                 summary += `â€¢ æ€»é‡é‡ï¼š${container.metrics.totalWeight.toFixed(0)}kg<br>`;
                 summary += `â€¢ é‡å¿ƒåç§»ï¼š${container.metrics.centerDeviation.toFixed(1)}cm<br>`;
                 summary += `â€¢ é¢„ä¼°æˆæœ¬ï¼šÂ¥${containerInfo.cost.toLocaleString()}<br>`;
                 
                 // ç»Ÿè®¡è¯¥é›†è£…ç®±å†…çš„è´§ç‰©
                 const cargoStats = {};
                 container.placements.forEach(placement => {
                     const cargoName = placement.cargo.name;
                     if (!cargoStats[cargoName]) {
                         cargoStats[cargoName] = { count: 0, totalWeight: 0 };
                     }
                     cargoStats[cargoName].count++;
                     cargoStats[cargoName].totalWeight += placement.cargo.weight;
                 });
                 
                 summary += `â€¢ è´§ç‰©æ¸…å•ï¼š`;
                 const cargoList = Object.entries(cargoStats).map(([name, stat]) => 
                     `${name}(${stat.count}ä»¶,${stat.totalWeight.toFixed(0)}kg)`
                 ).join('ã€');
                 summary += cargoList + `<br><br>`;
             });
             
             // è®¡ç®—æ€»çš„æœªè£…è½½è´§ç‰©
             const allPlacements = containers.flatMap(c => c.placements);
             const unloadedItems = [];
             cargoItems.forEach(cargo => {
                 const loadedCount = allPlacements.filter(p => p.cargo.id === cargo.id).length;
                 const remaining = cargo.quantity - loadedCount;
                 if (remaining > 0) {
                     unloadedItems.push(`${cargo.name}ï¼š${remaining}ä»¶`);
                 }
             });
             
             if (unloadedItems.length > 0) {
                 summary += `<strong>âš ï¸ æœªè£…è½½è´§ç‰©ï¼š</strong><br>`;
                 unloadedItems.forEach(item => {
                     summary += `â€¢ ${item}<br>`;
                 });
             }
             
             document.getElementById('packing-description').innerHTML = summary;
             document.getElementById('packing-summary').style.display = 'block';
         }
        
        // åˆ›å»ºå¤šé›†è£…ç®±3Då¯è§†åŒ–
        function createMultiContainerVisualization(containerSolution) {
            clearContainerDisplay();
            
            if (!containerSolution || !containerSolution.containers) return;
            
            const containers = containerSolution.containers;
            const spacing = 15; // é›†è£…ç®±ä¹‹é—´çš„é—´è·
            
            // è®¡ç®—å¤šè¡Œå¤šåˆ—å¸ƒå±€
            const containersPerRow = Math.ceil(Math.sqrt(containers.length)); // æ¯è¡Œé›†è£…ç®±æ•°é‡
            const totalRows = Math.ceil(containers.length / containersPerRow);
            
            containers.forEach((containerInstance, index) => {
                // è®¡ç®—è¡Œåˆ—ä½ç½®
                const row = Math.floor(index / containersPerRow);
                const col = index % containersPerRow;
                
                // è®¡ç®—é›†è£…ç®±ä½ç½®ï¼ˆå¤šè¡Œå¤šåˆ—å¸ƒå±€ï¼‰
                const offsetX = (col - (containersPerRow - 1) / 2) * spacing;
                const offsetZ = (row - (totalRows - 1) / 2) * spacing;
                
                containerInstance.scenePosition = { x: offsetX, y: 0, z: offsetZ };
                
                // åˆ›å»ºé›†è£…ç®±3Dæ¨¡å‹
                const containerGroup = createSingleContainerVisualization(containerInstance, offsetX, offsetZ);
                scene.add(containerGroup);
                
                // ä¸ºæ¯ä¸ªé›†è£…ç®±æ·»åŠ åœ°é¢å’Œåœ°æ ‡
                const dims = containerDimensions[containerInstance.type];
                createConcreteGroundForContainer(dims, offsetX, offsetZ);
                addSafetyMarkingsForContainer(dims, offsetX, offsetZ);
                
                // å­˜å‚¨åˆ°å®¹å™¨ç»„ä¸­
                if (!containerGroups) containerGroups = [];
                containerGroups.push({
                    containerGroup: containerGroup,
                    cargoGroup: containerGroup.children.find(child => child.children.some(c => c.userData.cargoInfo))
                });
            });
            
            // è°ƒæ•´ç›¸æœºè§†è§’ä»¥æ˜¾ç¤ºæ‰€æœ‰é›†è£…ç®±
            adjustCameraForMultiContainer(containers.length, spacing, containersPerRow, totalRows);
        }
        
        // åˆ›å»ºå•ä¸ªé›†è£…ç®±çš„3Då¯è§†åŒ–
        function createSingleContainerVisualization(containerInstance, offsetX, offsetZ = 0) {
            const containerGroup = new THREE.Group();
            const containerType = containerInstance.type;
            const container = containerDimensions[containerType];
            
            // åˆ›å»ºé›†è£…ç®±ä¸»ä½“
            const containerMesh = createContainerMesh(containerType);
            containerMesh.position.set(offsetX, 0, offsetZ);
            containerGroup.add(containerMesh);
            
            // åˆ›å»ºè´§ç‰©ç»„
            const cargoGroup = new THREE.Group();
            cargoGroup.position.set(offsetX, 0, offsetZ);
            
            // æ·»åŠ è´§ç‰©
            containerInstance.placements.forEach(placement => {
                const cargo = placement.cargo;
                
                // åˆ›å»ºè´§ç‰©3Dæ¨¡å‹
                const geometry = new THREE.BoxGeometry(cargo.length, cargo.height, cargo.width);
                const material = new THREE.MeshStandardMaterial({ 
                    color: cargo.color,
                    transparent: false
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    placement.position.x,
                    placement.position.y,
                    placement.position.z
                );
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // æ·»åŠ è´§ç‰©ä¿¡æ¯åˆ°userData
                mesh.userData.cargoInfo = {
                    name: cargo.name,
                    length: cargo.length,
                    width: cargo.width,
                    height: cargo.height,
                    weight: cargo.weight,
                    quantity: cargo.quantity,
                    fragile: cargo.fragile,
                    stackable: cargo.stackable,
                    containerIndex: containerGroups ? containerGroups.length : 0,
                    position: {
                        x: placement.position.x,
                        y: placement.position.y,
                        z: placement.position.z
                    }
                };
                
                // æ·»åŠ è¾¹æ¡†
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                mesh.add(line);
                
                cargoGroup.add(mesh);
            });
            
            containerGroup.add(cargoGroup);
            
            // æ·»åŠ é›†è£…ç®±æ ‡ç­¾
            // const label = createContainerLabel(containerType, containerInstance.metrics, offsetX, offsetZ);
            // containerGroup.add(label);
            
            return containerGroup;
        }
        
        // è°ƒæ•´ç›¸æœºä»¥æ˜¾ç¤ºå¤šä¸ªé›†è£…ç®±
        function adjustCameraForMultiContainer(containerCount, spacing, containersPerRow, totalRows) {
            if (containerCount <= 1) return;
            
            const totalWidth = (containersPerRow - 1) * spacing;
            const totalDepth = (totalRows - 1) * spacing;
            const centerX = 0; // å·²ç»å±…ä¸­
            const centerZ = 0; // å·²ç»å±…ä¸­
            
            // è®¡ç®—åˆé€‚çš„ç›¸æœºè·ç¦»
            const maxDimension = Math.max(totalWidth, totalDepth);
            const cameraDistance = Math.max(20, maxDimension * 0.8 + 15);
            
            // è°ƒæ•´ç›¸æœºä½ç½®
            camera.position.set(centerX + cameraDistance, 15, centerZ + cameraDistance);
            controls.target.set(centerX, 0, centerZ);
            controls.update();
        }
        
        // æ›´æ–°å¤šé›†è£…ç®±æŒ‡æ ‡
         function updateMultiContainerMetrics(containerSolution) {
             if (!containerSolution) return;
             
             const metrics = containerSolution.totalMetrics;
             
             // æ›´æ–°å¤šé›†è£…ç®±æŒ‡æ ‡æ˜¾ç¤º
             document.getElementById('container-count').textContent = metrics.containerCount;
             document.getElementById('total-cost').textContent = 'Â¥' + metrics.totalCost.toLocaleString();
             document.getElementById('avg-utilization').textContent = metrics.avgUtilization.toFixed(1) + '%';
             document.getElementById('unloaded-items').textContent = metrics.totalUnloadedItems;
             
             // æ›´æ–°é›†è£…ç®±è¯¦æƒ…
             updateContainerDetails(containerSolution.containers);
             
             // ç”Ÿæˆå¹¶æ˜¾ç¤ºè£…ç®±è¯´æ˜
             generatePackingSummary(containerSolution);
         }
        
        // æ›´æ–°é›†è£…ç®±è¯¦æƒ…æ˜¾ç¤º
        function updateContainerDetails(containers) {
            const detailsContainer = document.getElementById('container-details');
            detailsContainer.innerHTML = '';
            
            containers.forEach((container, index) => {
                const containerDiv = document.createElement('div');
                containerDiv.className = 'container-detail-item';
                containerDiv.innerHTML = `
                    <h4>é›†è£…ç®± ${index + 1} (${container.type})</h4>
                    <div class="detail-metrics">
                        <span>åˆ©ç”¨ç‡: ${container.metrics.loadRatio.toFixed(1)}%</span>
                        <span>è´§ç‰©æ•°: ${container.metrics.loadedItems}</span>
                        <span>é‡é‡: ${container.metrics.totalWeight.toFixed(0)}kg</span>
                        <span>é‡å¿ƒåç§»: ${container.metrics.centerDeviation.toFixed(1)}cm</span>
                    </div>
                `;
                detailsContainer.appendChild(containerDiv);
            });
        }
        
        // è®¡ç®—é‡å¿ƒåç§»
        function calculateCenterDeviation(placements, container) {
            if (placements.length === 0) return 0;
            
            let totalWeight = 0;
            let weightedX = 0;
            let weightedZ = 0;
            
            placements.forEach(placement => {
                const weight = placement.cargo.weight;
                totalWeight += weight;
                weightedX += placement.position.x * weight;
                weightedZ += placement.position.z * weight;
            });
            
            const centerX = weightedX / totalWeight;
            const centerZ = weightedZ / totalWeight;
            
            // è®¡ç®—åç¦»å®¹å™¨ä¸­å¿ƒçš„è·ç¦»
            const deviation = Math.sqrt(centerX * centerX + centerZ * centerZ);
            return deviation * 100; // è½¬æ¢ä¸ºå˜ç±³
        }
        
        // ä¿å­˜æ–¹æ¡ˆ
        function saveSolution() {
            if (!currentSolution) {
                alert('è¯·å…ˆç”Ÿæˆè£…ç®±æ–¹æ¡ˆï¼');
                return;
            }
            
            solutions.push(currentSolution);
            updateSolutionsList();
            alert('æ–¹æ¡ˆå·²ä¿å­˜ï¼');
        }
        
        // æ›´æ–°æ–¹æ¡ˆåˆ—è¡¨
        function updateSolutionsList() {
            const container = document.getElementById('solutions-list');
            container.innerHTML = '';
            
            solutions.forEach((solution, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 5px; font-size: 12px;';
                div.innerHTML = `
                    <strong>æ–¹æ¡ˆ ${index + 1}</strong> (${solution.algorithm})<br>
                    è£…è½½ç‡: ${solution.metrics.loadRatio}% | è´§ç‰©: ${solution.metrics.loadedItems}ä»¶<br>
                    <button class="btn" style="padding: 2px 8px; margin-top: 5px;" onclick="loadSolution(${index})">åŠ è½½</button>
                    <button class="btn btn-danger" style="padding: 2px 8px; margin-top: 5px;" onclick="deleteSolution(${index})">åˆ é™¤</button>
                `;
                container.appendChild(div);
            });
        }
        
        // åŠ è½½æ–¹æ¡ˆ
        function loadSolution(index) {
            const solution = solutions[index];
            // è¿™é‡Œå¯ä»¥å®ç°åŠ è½½æŒ‡å®šæ–¹æ¡ˆçš„é€»è¾‘
            alert(`åŠ è½½æ–¹æ¡ˆ ${index + 1}`);
        }
        
        // åˆ é™¤æ–¹æ¡ˆ
        function deleteSolution(index) {
            solutions.splice(index, 1);
            updateSolutionsList();
        }
        
        // æ¸…ç©ºæ‰€æœ‰æ–¹æ¡ˆ
        function clearSolutions() {
            solutions = [];
            updateSolutionsList();
        }
        
        // é‡ç½®ç›¸æœº
        function resetCamera() {
            const containerType = document.getElementById('container-type').value;
            const dims = containerDimensions[containerType];
            camera.position.set(dims.length * 1.5, dims.height * 2, dims.width * 1.5);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        // åˆ‡æ¢çº¿æ¡†æ¨¡å¼
        let wireframeMode = false;
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            if (cargoGroup) {
                cargoGroup.children.forEach(mesh => {
                    if (mesh.material) {
                        mesh.material.wireframe = wireframeMode;
                    }
                });
            }
        }
        
        // æ”¹å˜è§†å›¾
        function changeView() {
            const viewMode = document.getElementById('view-mode').value;
            const containerType = document.getElementById('container-type').value;
            const dims = containerDimensions[containerType];
            
            switch(viewMode) {
                case 'top':
                    camera.position.set(0, dims.height * 3, 0);
                    break;
                case 'side':
                    camera.position.set(dims.length * 2, dims.height, 0);
                    break;
                case 'front':
                    camera.position.set(0, dims.height, dims.width * 2);
                    break;
                default:
                    camera.position.set(dims.length * 1.5, dims.height * 2, dims.width * 1.5);
            }
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        // å¯¼å‡ºåŠŸèƒ½
        function exportModel() {
            alert('3Dæ¨¡å‹å¯¼å‡ºåŠŸèƒ½ï¼ˆéœ€è¦é›†æˆGLTFExporterï¼‰');
        }
        
        function exportPDF() {
            alert('PDFå¯¼å‡ºåŠŸèƒ½ï¼ˆéœ€è¦é›†æˆjsPDFåº“ï¼‰');
        }
        
        function exportExcel() {
            alert('Excelå¯¼å‡ºåŠŸèƒ½ï¼ˆéœ€è¦é›†æˆSheetJSåº“ï¼‰');
        }
        
        // ä¸‹è½½æ¨¡æ¿
        function downloadTemplate() {
            const csvContent = "è´§ç‰©åç§°,é•¿(m),å®½(m),é«˜(m),é‡é‡(kg),æ•°é‡,æ˜“ç¢å“,å¯å †å \nçº¸ç®±,1.2,0.8,1.0,100,10,å¦,æ˜¯\næœºæ¢°è®¾å¤‡,2.0,1.5,1.8,500,2,æ˜¯,å¦";
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'è´§ç‰©ä¿¡æ¯æ¨¡æ¿.csv';
            link.click();
        }
        
        // å¯¼å…¥è´§ç‰©
        function importCargo() {
            const fileInput = document.getElementById('csv-file');
            if (!fileInput.files[0]) {
                alert('è¯·é€‰æ‹©æ–‡ä»¶ï¼');
                return;
            }
            
            const file = fileInput.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const csv = e.target.result;
                const lines = csv.split('\n');
                
                // è·³è¿‡æ ‡é¢˜è¡Œ
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        const data = line.split(',');
                        if (data.length >= 6) {
                            const cargo = new Cargo({
                                name: data[0],
                                length: data[1],
                                width: data[2],
                                height: data[3],
                                weight: data[4],
                                quantity: data[5],
                                fragile: data[6] === 'æ˜¯' ? 'true' : 'false',
                                stackable: data[7] === 'å¦' ? 'false' : 'true'
                            });
                            cargoItems.push(cargo);
                        }
                    }
                }
                
                updateCargoList();
                alert(`æˆåŠŸå¯¼å…¥ ${lines.length - 1} æ¡è´§ç‰©ä¿¡æ¯ï¼`);
            };
            
            reader.readAsText(file);
        }
        
        // é‡ç½®æ‰€æœ‰
        function resetAll() {
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ•°æ®å—ï¼Ÿ')) {
                cargoItems = [];
                solutions = [];
                currentSolution = null;
                
                if (cargoGroup) scene.remove(cargoGroup);
                
                updateCargoList();
                updateSolutionsList();
                
                document.getElementById('load-ratio').textContent = '0%';
                document.getElementById('loaded-items').textContent = '0';
                document.getElementById('total-weight').textContent = '0kg';
                document.getElementById('center-deviation').textContent = '0cm';
            }
        }
        
        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶å¤„ç†
        function onMouseMove(event) {
            const container = document.getElementById('scene-container');
            const rect = container.getBoundingClientRect();
            
            // è®¡ç®—é¼ æ ‡åœ¨å®¹å™¨ä¸­çš„ç›¸å¯¹ä½ç½®
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // å°„çº¿æ£€æµ‹
            raycaster.setFromCamera(mouse, camera);
            
            let foundContainer = false;
            
            // æ£€æµ‹é›†è£…ç®±ï¼ˆå¤šé›†è£…ç®±æ¨¡å¼ï¼‰
            if (containerGroups && containerGroups.length > 0) {
                for (let i = 0; i < containerGroups.length; i++) {
                    const containerGroupData = containerGroups[i];
                    if (containerGroupData && containerGroupData.containerGroup) {
                        const intersects = raycaster.intersectObjects(containerGroupData.containerGroup.children, true);
                        
                        if (intersects.length > 0) {
                            const intersectedObject = intersects[0].object;
                            
                            // æŸ¥æ‰¾é›†è£…ç®±ç½‘æ ¼å¯¹è±¡
                            let containerMesh = intersectedObject;
                            while (containerMesh && !containerMesh.userData.isContainer) {
                                containerMesh = containerMesh.parent;
                                if (containerMesh === containerGroupData.containerGroup) {
                                    containerMesh = null;
                                    break;
                                }
                            }
                            
                            if (containerMesh && containerMesh.userData.isContainer) {
                                const containerInfo = getContainerInfo(containerMesh.userData.containerType, i);
                                if (hoveredContainer !== containerMesh) {
                                    hoveredContainer = containerMesh;
                                    showContainerTooltip(event, containerInfo);
                                } else {
                                    updateTooltipPosition(event);
                                }
                                foundContainer = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            // æ£€æµ‹é›†è£…ç®±ï¼ˆå•é›†è£…ç®±æ¨¡å¼ï¼‰
            if (!foundContainer && containerGroup) {
                const intersects = raycaster.intersectObjects(containerGroup.children, true);
                
                if (intersects.length > 0) {
                    const intersectedObject = intersects[0].object;
                    
                    // æŸ¥æ‰¾é›†è£…ç®±ç½‘æ ¼å¯¹è±¡
                    let containerMesh = intersectedObject;
                    while (containerMesh && !containerMesh.userData.isContainer) {
                        containerMesh = containerMesh.parent;
                        if (containerMesh === containerGroup) {
                            containerMesh = null;
                            break;
                        }
                    }
                    
                    if (containerMesh && containerMesh.userData.isContainer) {
                        const containerInfo = getContainerInfo(containerMesh.userData.containerType, 0);
                        if (hoveredContainer !== containerMesh) {
                            hoveredContainer = containerMesh;
                            showContainerTooltip(event, containerInfo);
                        } else {
                            updateTooltipPosition(event);
                        }
                        foundContainer = true;
                    }
                }
            }
            
            if (!foundContainer) {
                // æ²¡æœ‰æ‚¬åœåœ¨é›†è£…ç®±ä¸Šï¼Œéšè—æç¤ºæ¡†
                hideContainerTooltip();
            }
        }
        
        // é¼ æ ‡ç¦»å¼€äº‹ä»¶å¤„ç†
        function onMouseLeave(event) {
            hideContainerTooltip();
        }
        
        // é˜²æŠ–å®šæ—¶å™¨
        let tooltipShowTimer = null;
        let tooltipHideTimer = null;
        
        // æ‚¬åœçš„é›†è£…ç®±å¯¹è±¡
        let hoveredContainer = null;
        
        // è·å–é›†è£…ç®±ä¿¡æ¯
        function getContainerInfo(containerType, containerIndex) {
            const dims = containerDimensions[containerType];
            let containerData = {
                type: containerType,
                dimensions: dims,
                index: containerIndex
            };
            
            // è·å–é›†è£…ç®±çš„è£…è½½ä¿¡æ¯
            if (multiContainerMode && multiContainerSolution && multiContainerSolution.containers) {
                const container = multiContainerSolution.containers[containerIndex];
                if (container) {
                    containerData.metrics = container.metrics;
                    containerData.placements = container.placements;
                }
            } else if (!multiContainerMode && currentSolution) {
                containerData.metrics = currentSolution.metrics;
                containerData.placements = currentSolution.placements;
            }
            
            return containerData;
        }
        
        // æ˜¾ç¤ºé›†è£…ç®±ä¿¡æ¯æç¤ºæ¡†
        function showContainerTooltip(event, containerInfo) {
            // æ¸…é™¤éšè—å®šæ—¶å™¨
            if (tooltipHideTimer) {
                clearTimeout(tooltipHideTimer);
                tooltipHideTimer = null;
            }
            
            // å¦‚æœå·²æœ‰æç¤ºæ¡†ï¼Œåªæ›´æ–°ä½ç½®
            if (tooltip) {
                updateTooltipPosition(event);
                return;
            }
            
            // æ¸…é™¤æ˜¾ç¤ºå®šæ—¶å™¨
            if (tooltipShowTimer) {
                clearTimeout(tooltipShowTimer);
            }
            
            // å»¶è¿Ÿæ˜¾ç¤ºæç¤ºæ¡†ï¼Œé¿å…å¿«é€Ÿç§»åŠ¨æ—¶é¢‘ç¹åˆ›å»º
            tooltipShowTimer = setTimeout(() => {
                // å¦‚æœå·²ç»æœ‰æç¤ºæ¡†äº†ï¼Œä¸é‡å¤åˆ›å»º
                if (tooltip) {
                    return;
                }
                
                tooltip = document.createElement('div');
                tooltip.className = 'cargo-tooltip';
                
                const dims = containerInfo.dimensions;
                const metrics = containerInfo.metrics;
                const placements = containerInfo.placements || [];
                
                let content = `
                    <div class="cargo-name">é›†è£…ç®± ${containerInfo.type}</div>
                    <div class="cargo-info">å°ºå¯¸: ${dims.length.toFixed(1)}Ã—${dims.width.toFixed(1)}Ã—${dims.height.toFixed(1)}m</div>
                    <div class="cargo-info">æœ€å¤§è½½é‡: ${dims.maxWeight.toLocaleString()}kg</div>
                    <div class="cargo-info">é¢„ä¼°æˆæœ¬: Â¥${dims.cost.toLocaleString()}</div>
                `;
                
                if (metrics) {
                    content += `
                        <div class="cargo-info">è£…è½½ç‡: ${metrics.loadRatio.toFixed(1)}%</div>
                        <div class="cargo-info">å·²è£…è´§ç‰©: ${metrics.loadedItems}ä»¶</div>
                        <div class="cargo-info">æ€»é‡é‡: ${metrics.totalWeight.toFixed(0)}kg</div>
                    `;
                    
                    if (metrics.centerDeviation !== undefined) {
                        content += `<div class="cargo-info">é‡å¿ƒåç§»: ${metrics.centerDeviation.toFixed(1)}cm</div>`;
                    }
                }
                
                tooltip.innerHTML = content;
                document.body.appendChild(tooltip);
                
                updateTooltipPosition(event);
                
                // è§¦å‘æ˜¾ç¤ºåŠ¨ç”»
                requestAnimationFrame(() => {
                    if (tooltip) {
                        tooltip.classList.add('show');
                    }
                });
            }, 150); // å¢åŠ å»¶è¿Ÿåˆ°150msï¼Œå‡å°‘é—ªçƒ
        }
        
        // æ›´æ–°æç¤ºæ¡†ä½ç½®
        function updateTooltipPosition(event) {
            if (!tooltip) return;
            
            const offsetX = 12;
            const offsetY = 12;
            
            let left = event.clientX + offsetX;
            let top = event.clientY + offsetY;
            
            // é˜²æ­¢æç¤ºæ¡†è¶…å‡ºå±å¹•è¾¹ç•Œ
            const tooltipRect = tooltip.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            if (left + tooltipRect.width > windowWidth) {
                left = event.clientX - tooltipRect.width - offsetX;
            }
            
            if (top + tooltipRect.height > windowHeight) {
                top = event.clientY - tooltipRect.height - offsetY;
            }
            
            // æ·»åŠ è¾¹ç•Œå®‰å…¨è·ç¦»
            left = Math.max(8, Math.min(left, windowWidth - tooltipRect.width - 8));
            top = Math.max(8, Math.min(top, windowHeight - tooltipRect.height - 8));
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        // éšè—é›†è£…ç®±ä¿¡æ¯æç¤ºæ¡†
        function hideContainerTooltip() {
            // æ¸…é™¤æ˜¾ç¤ºå®šæ—¶å™¨
            if (tooltipShowTimer) {
                clearTimeout(tooltipShowTimer);
                tooltipShowTimer = null;
            }
            
            if (tooltip) {
                // æ·»åŠ éšè—åŠ¨ç”»
                tooltip.classList.remove('show');
                tooltip.classList.add('hide');
                
                // å»¶è¿Ÿç§»é™¤DOMå…ƒç´ 
                tooltipHideTimer = setTimeout(() => {
                    if (tooltip && tooltip.parentNode) {
                        document.body.removeChild(tooltip);
                    }
                    tooltip = null;
                    tooltipHideTimer = null;
                }, 150); // ä¸CSSåŠ¨ç”»æ—¶é—´åŒ¹é…
            }
            hoveredContainer = null;
        }
        
        // æ˜¾ç¤ºé›†è£…ç®±æ ‡ç­¾
        function showContainerLabel(containerGroupObj) {
            // å…ˆéšè—æ‰€æœ‰æ ‡ç­¾
            hideAllContainerLabels();
            
            // æ˜¾ç¤ºå½“å‰é›†è£…ç®±çš„æ ‡ç­¾
            containerGroupObj.children.forEach(child => {
                if (child.userData.isContainerLabel) {
                    child.material.opacity = 1;
                }
            });
        }
        
        // éšè—æ‰€æœ‰é›†è£…ç®±æ ‡ç­¾
        function hideAllContainerLabels() {
            // éšè—å¤šé›†è£…ç®±æ¨¡å¼çš„æ ‡ç­¾
            if (containerGroups && containerGroups.length > 0) {
                for (let i = 0; i < containerGroups.length; i++) {
                    const containerGroupData = containerGroups[i];
                    if (containerGroupData && containerGroupData.containerGroup) {
                        containerGroupData.containerGroup.children.forEach(child => {
                            if (child.userData.isContainerLabel) {
                                child.material.opacity = 0;
                            }
                        });
                    }
                }
            }
            
            // éšè—å•é›†è£…ç®±æ¨¡å¼çš„æ ‡ç­¾
            if (containerGroup) {
                containerGroup.children.forEach(child => {
                    if (child.userData.isContainerLabel) {
                        child.material.opacity = 0;
                    }
                });
            }
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', function() {
            const container = document.getElementById('scene-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initScene();
        });
    </script>
</body>
</html>